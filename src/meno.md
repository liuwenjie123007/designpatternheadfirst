#### OO基础

- 抽象
- 封装
- 多态
- 继承

#### OO原则

- 封装变化
  - 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要的变化代码混在一起
- 针对接口编程，而不是针对实现编程
- 多用组合，少用继承
- 为了交互对象之间的松耦合设计而努力
- 对扩展开放，对修改关闭
- 依赖抽象，不要依赖具体类
- 知识最少原则：只和你的密友谈话
- 好莱坞原则：别调用我们，我们会调用你。
- 单一责任：类应该只有一个改变的理由

#### OO模式
- 策略模式
  - 定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
- 观察者模式
  - 在对象之间定一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新。
- 装饰者模式
  - 动态地将责任附加到对象上。想要扩展功能，装饰者提供有别于继承的另一种选择。
- 抽象工厂模式
  - 提供一个接口，用于创建相关或依赖对象的家族，而不要明确指定具体类。
- 工厂方法模式
  - 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。
- 单件模式
  - 确保一个类只有一个实例，并提供全局访问点。
- 命令模式
  - 将请求封装成对象，这可以让你使用不同的请求，队列，或者日志请求来参数化其他对象。命令模式也可以支持撤销操作。
- 适配器模式
  - 将一个类的接口，转换成客户期望另一个接口。适配器让原本不兼容的类可以合作无间。
- 外观模式
  - 提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。
- 模版方法模式
  - 在一个方法中定一个算法的骨架，而将一些步骤延迟到子类中。模版方法使得子类可以在不改变算法接口的情况下，重新定义算法中的某些步骤。
- 迭代器模式
  - 提供一种方法顺序访问一个聚合对象中的各个元素，而不是暴露其内部的表示。
- 组合模式
  - 允许你讲对象组成树形结构来表现"整体/部分"的层次接口。组合能让客户以一致的方式处理个别对象和对象组合。
- 状态模式
  - 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
- 代理模式
  - 为另一个对象提供一个替身或占位符以访问这个对象。
- 复合模式
  - 复合模式结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题。
- 桥接模式
  - 不只改变你的实现，也改变你的抽象
- 生成器模式
  - 封装一个产品的构造过程，并允许按步骤构造。
- 责任链模式
  - 让一个以上的对象由机会能够处理某个请求。
- 蝇量模式（Flyweight Patter）
  - 让某个类的一个实例能够用来提供许多"虚拟实例"。
- 解释器模式
  - 为语言创建解释器。
- 中介者模式
  - 集中相关对象之间复杂的沟通和控制方式。
- 备忘录模式
  - 让对象返回之前的状态。
- 原型模式
  - 创建给定类的实例的过程昂贵或很复杂时，使用原型模式。
- 访问者模式
  - 为一个对象的组合增加新的能力，且封装并不重要时使用。